/*!
 * \file 	[UWindow.c]
 *
 * \author 	[Bassem]
 * \date	06-21-09
 *
 * Main Micro Windows File with all object Drawing and APIs
 */
#include <mios32.h>
#include <app_lcd.h>

#include "UWindows.h"
#include "UW_CharSet.h"

#ifdef _MIOS32_CONFIG_H
#define MAX_X	(APP_LCD_NUM_X*APP_LCD_WIDTH)
#define MAX_Y	(APP_LCD_NUM_Y*APP_LCD_HEIGHT)
#else
#define MAX_X	128
#define MAX_Y	64
#endif
const char ExitLabel[] = "SHUT DOWN";
bool			Refresh;
bool			bExit;
UW_Window		UWindows;
UW_Window		ExitBtn;
#ifdef _MIOS32_CONFIG_H
u8			UWImage[APP_LCD_BITMAP_SIZE];
mios32_lcd_bitmap_t     UWBitmap;
#else
u8				UWImage [4 * 1040];
#endif
u16 			Colors[4]={BLACK,BLUE,GRAY,WHITE};
UW_Window	*	pUW_Infocus;
u8			CursorXPos,CursorYPos;
const u8 CurrentFont[224 * 14] = {
    /* ASCII 32  */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 33  */  0x00,0x00,0x00,0x00,0x00,0x00,0x13,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 34  */  0x00,0x00,0x00,0xe0,0x00,0x20,0x00,0x00,0x00,0xe0,0x00,0x20,0x00,0x00,
    /* ASCII 35  */  0x00,0x00,0x35,0x00,0x0f,0x80,0x35,0x60,0x0f,0x80,0x05,0x60,0x00,0x00,
    /* ASCII 36  */  0x00,0x00,0x0d,0x80,0x0a,0x40,0x3a,0x60,0x06,0x40,0x00,0x00,0x00,0x00,
    /* ASCII 37  */  0x00,0x00,0x02,0x40,0x02,0xa0,0x0a,0x40,0x15,0x00,0x09,0x00,0x00,0x00,
    /* ASCII 38  */  0x00,0x00,0x0c,0x00,0x13,0x00,0x14,0x80,0x08,0x80,0x14,0x00,0x00,0x00,
    /* ASCII 39  */  0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 40  */  0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x80,0x60,0x60,0x00,0x00,0x00,0x00,
    /* ASCII 41  */  0x00,0x00,0x00,0x00,0x60,0x60,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 42  */  0x00,0x00,0x00,0x40,0x03,0x40,0x00,0xe0,0x03,0x40,0x00,0x40,0x00,0x00,
    /* ASCII 43  */  0x02,0x00,0x02,0x00,0x02,0x00,0x1f,0xc0,0x02,0x00,0x02,0x00,0x02,0x00,
    /* ASCII 44  */  0x00,0x00,0x00,0x00,0x60,0x00,0x38,0x00,0x08,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 45  */  0x00,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x00,0x00,
    /* ASCII 46  */  0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 47  */  0x00,0x00,0x20,0x00,0x18,0x00,0x06,0x00,0x01,0x80,0x00,0x60,0x00,0x00,
    /* ASCII 48  */  0x00,0x00,0x0f,0xc0,0x10,0x20,0x10,0x20,0x10,0x20,0x0f,0xc0,0x00,0x00,
    /* ASCII 49  */  0x00,0x00,0x10,0x00,0x10,0x20,0x1f,0xe0,0x10,0x00,0x10,0x00,0x00,0x00,
    /* ASCII 50  */  0x00,0x00,0x18,0x40,0x14,0x20,0x12,0x20,0x11,0x20,0x18,0xc0,0x00,0x00,
    /* ASCII 51  */  0x00,0x00,0x08,0x40,0x10,0x20,0x11,0x20,0x11,0x20,0x0e,0xc0,0x00,0x00,
    /* ASCII 52  */  0x00,0x00,0x06,0x00,0x05,0x00,0x04,0xc0,0x14,0x20,0x1f,0xe0,0x14,0x00,
    /* ASCII 53  */  0x00,0x00,0x08,0x00,0x11,0xe0,0x11,0x20,0x11,0x20,0x0e,0x20,0x00,0x00,
    /* ASCII 54  */  0x00,0x00,0x0f,0x80,0x11,0x40,0x11,0x20,0x11,0x20,0x0e,0x20,0x00,0x00,
    /* ASCII 55  */  0x00,0x00,0x00,0x60,0x00,0x20,0x18,0x20,0x07,0x20,0x00,0xe0,0x00,0x00,
    /* ASCII 56  */  0x00,0x00,0x0e,0xc0,0x11,0x20,0x11,0x20,0x11,0x20,0x0e,0xc0,0x00,0x00,
    /* ASCII 57  */  0x00,0x00,0x11,0xc0,0x12,0x20,0x12,0x20,0x0a,0x20,0x07,0xc0,0x00,0x00,
    /* ASCII 58  */  0x00,0x00,0x00,0x00,0x19,0x80,0x19,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 59  */  0x00,0x00,0x00,0x00,0x30,0x00,0x19,0x80,0x09,0x80,0x00,0x00,0x00,0x00,
    /* ASCII 60  */  0x02,0x00,0x05,0x00,0x05,0x00,0x08,0x80,0x10,0x40,0x10,0x40,0x00,0x00,
    /* ASCII 61  */  0x00,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x00,0x00,
    /* ASCII 62  */  0x10,0x40,0x10,0x40,0x08,0x80,0x05,0x00,0x05,0x00,0x02,0x00,0x00,0x00,
    /* ASCII 63  */  0x00,0x00,0x00,0x00,0x10,0x80,0x14,0x40,0x02,0x40,0x01,0x80,0x00,0x00,
    /* ASCII 64  */  0x00,0x00,0x1f,0xe0,0x20,0x10,0x23,0x10,0x24,0x90,0x17,0xe0,0x00,0x00,
    /* ASCII 65  */  0x10,0x00,0x1c,0x00,0x17,0xa0,0x04,0x60,0x17,0x80,0x1c,0x00,0x10,0x00,
    /* ASCII 66  */  0x10,0x20,0x1f,0xe0,0x11,0x20,0x11,0x20,0x11,0x20,0x0e,0xc0,0x00,0x00,
    /* ASCII 67  */  0x00,0x00,0x0f,0xc0,0x10,0x20,0x10,0x20,0x10,0x20,0x08,0x60,0x00,0x00,
    /* ASCII 68  */  0x10,0x20,0x1f,0xe0,0x10,0x20,0x10,0x20,0x08,0x40,0x07,0x80,0x00,0x00,
    /* ASCII 69  */  0x10,0x20,0x1f,0xe0,0x11,0x20,0x13,0xa0,0x10,0x20,0x18,0x60,0x00,0x00,
    /* ASCII 70  */  0x00,0x00,0x10,0x20,0x1f,0xe0,0x11,0x20,0x03,0xa0,0x00,0x20,0x00,0x60,
    /* ASCII 71  */  0x00,0x00,0x0f,0xc0,0x10,0x20,0x10,0x20,0x12,0x20,0x0e,0x60,0x02,0x00,
    /* ASCII 72  */  0x10,0x20,0x1f,0xe0,0x11,0x20,0x01,0x00,0x11,0x20,0x1f,0xe0,0x10,0x20,
    /* ASCII 73  */  0x00,0x00,0x10,0x20,0x10,0x20,0x1f,0xe0,0x10,0x20,0x10,0x20,0x00,0x00,
    /* ASCII 74  */  0x00,0x00,0x0e,0x00,0x10,0x20,0x10,0x20,0x0f,0xe0,0x00,0x20,0x00,0x00,
    /* ASCII 75  */  0x10,0x20,0x1f,0xe0,0x12,0x20,0x03,0x00,0x04,0xa0,0x18,0x60,0x10,0x20,
    /* ASCII 76  */  0x00,0x00,0x10,0x20,0x1f,0xe0,0x10,0x20,0x10,0x00,0x1c,0x00,0x00,0x00,
    /* ASCII 77  */  0x10,0x20,0x1f,0xe0,0x10,0xe0,0x03,0x00,0x10,0xe0,0x1f,0xe0,0x10,0x20,
    /* ASCII 78  */  0x10,0x20,0x1f,0xe0,0x10,0xe0,0x07,0x00,0x18,0x20,0x1f,0xe0,0x00,0x20,
    /* ASCII 79  */  0x00,0x00,0x0f,0xc0,0x10,0x20,0x10,0x20,0x10,0x20,0x0f,0xc0,0x00,0x00,
    /* ASCII 80  */  0x00,0x00,0x10,0x20,0x1f,0xe0,0x12,0x20,0x02,0x20,0x01,0xc0,0x00,0x00,
    /* ASCII 81  */  0x00,0x00,0x0f,0xc0,0x10,0x20,0x30,0x20,0x30,0x20,0x2f,0xc0,0x00,0x00,
    /* ASCII 82  */  0x10,0x20,0x1f,0xe0,0x12,0x20,0x02,0x20,0x06,0x20,0x09,0xc0,0x10,0x00,
    /* ASCII 83  */  0x00,0x00,0x18,0xc0,0x09,0x20,0x11,0x20,0x11,0x40,0x0e,0x60,0x00,0x00,
    /* ASCII 84  */  0x00,0x60,0x00,0x20,0x10,0x20,0x1f,0xe0,0x10,0x20,0x00,0x20,0x00,0x60,
    /* ASCII 85  */  0x00,0x20,0x0f,0xe0,0x10,0x20,0x10,0x00,0x10,0x20,0x0f,0xe0,0x00,0x20,
    /* ASCII 86  */  0x00,0x20,0x00,0xe0,0x07,0x20,0x18,0x00,0x07,0x20,0x00,0xe0,0x00,0x20,
    /* ASCII 87  */  0x00,0x20,0x0f,0xe0,0x10,0x20,0x0f,0x00,0x10,0x20,0x0f,0xe0,0x00,0x20,
    /* ASCII 88  */  0x10,0x20,0x18,0x60,0x04,0x80,0x03,0x00,0x04,0x80,0x18,0x60,0x10,0x20,
    /* ASCII 89  */  0x00,0x20,0x00,0x60,0x11,0xa0,0x1e,0x00,0x11,0xa0,0x00,0x60,0x00,0x20,
    /* ASCII 90  */  0x00,0x00,0x18,0x60,0x14,0x20,0x13,0x20,0x10,0xa0,0x18,0x60,0x00,0x00,
    /* ASCII 91  */  0x00,0x00,0x00,0x00,0x7f,0xe0,0x40,0x20,0x40,0x20,0x00,0x00,0x00,0x00,
    /* ASCII 92  */  0x00,0x00,0x00,0x20,0x01,0xc0,0x06,0x00,0x38,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 93  */  0x00,0x00,0x00,0x00,0x40,0x20,0x40,0x20,0x7f,0xe0,0x00,0x00,0x00,0x00,
    /* ASCII 94  */  0x00,0x00,0x01,0x00,0x00,0x80,0x00,0x60,0x00,0x80,0x01,0x00,0x00,0x00,
    /* ASCII 95  */  0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,
    /* ASCII 96  */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x00,0x00,0x00,
    /* ASCII 97  */  0x00,0x00,0x0d,0x00,0x12,0x80,0x12,0x80,0x12,0x80,0x1f,0x00,0x10,0x00,
    /* ASCII 98  */  0x10,0x20,0x1f,0xe0,0x11,0x00,0x10,0x80,0x10,0x80,0x0f,0x00,0x00,0x00,
    /* ASCII 99  */  0x00,0x00,0x0f,0x00,0x10,0x80,0x10,0x80,0x10,0x80,0x09,0x80,0x00,0x00,
    /* ASCII 100 */  0x00,0x00,0x0f,0x00,0x10,0x80,0x10,0x80,0x11,0x20,0x1f,0xe0,0x10,0x00,
    /* ASCII 101 */  0x00,0x00,0x0f,0x00,0x12,0x80,0x12,0x80,0x12,0x80,0x13,0x00,0x00,0x00,
    /* ASCII 102 */  0x00,0x00,0x10,0x80,0x1f,0xc0,0x10,0xa0,0x10,0xa0,0x10,0xa0,0x00,0x00,
    /* ASCII 103 */  0x00,0x00,0x0f,0x00,0x50,0x80,0x50,0x80,0x51,0x00,0x3f,0x80,0x00,0x80,
    /* ASCII 104 */  0x10,0x20,0x1f,0xe0,0x11,0x00,0x00,0x80,0x10,0x80,0x1f,0x00,0x10,0x00,
    /* ASCII 105 */  0x00,0x00,0x10,0x80,0x10,0x80,0x1f,0xa0,0x10,0x00,0x10,0x00,0x00,0x00,
    /* ASCII 106 */  0x00,0x00,0x40,0x80,0x40,0x80,0x40,0xa0,0x3f,0x80,0x00,0x00,0x00,0x00,
    /* ASCII 107 */  0x10,0x20,0x1f,0xe0,0x02,0x00,0x16,0x80,0x19,0x80,0x10,0x80,0x00,0x00,
    /* ASCII 108 */  0x00,0x00,0x10,0x00,0x10,0x20,0x1f,0xe0,0x10,0x00,0x10,0x00,0x00,0x00,
    /* ASCII 109 */  0x10,0x80,0x1f,0x80,0x10,0x80,0x1f,0x00,0x10,0x80,0x1f,0x00,0x10,0x00,
    /* ASCII 110 */  0x10,0x80,0x1f,0x80,0x11,0x00,0x00,0x80,0x10,0x80,0x1f,0x00,0x10,0x00,
    /* ASCII 111 */  0x00,0x00,0x0f,0x00,0x10,0x80,0x10,0x80,0x10,0x80,0x0f,0x00,0x00,0x00,
    /* ASCII 112 */  0x40,0x80,0x7f,0x80,0x51,0x00,0x10,0x80,0x10,0x80,0x0f,0x00,0x00,0x00,
    /* ASCII 113 */  0x00,0x00,0x0f,0x00,0x10,0x80,0x10,0x80,0x51,0x00,0x7f,0x80,0x40,0x80,
    /* ASCII 114 */  0x00,0x00,0x10,0x80,0x1f,0x80,0x11,0x00,0x10,0x80,0x10,0x80,0x00,0x00,
    /* ASCII 115 */  0x00,0x00,0x19,0x00,0x12,0x80,0x12,0x80,0x12,0x80,0x0d,0x80,0x00,0x00,
    /* ASCII 116 */  0x00,0x00,0x00,0x80,0x0f,0xc0,0x10,0x80,0x10,0x80,0x10,0x80,0x08,0x00,
    /* ASCII 117 */  0x00,0x80,0x0f,0x80,0x10,0x00,0x10,0x00,0x08,0x80,0x1f,0x80,0x10,0x00,
    /* ASCII 118 */  0x00,0x80,0x03,0x80,0x0c,0x80,0x10,0x00,0x0c,0x80,0x03,0x80,0x00,0x80,
    /* ASCII 119 */  0x00,0x80,0x0f,0x80,0x10,0x80,0x0e,0x00,0x10,0x80,0x0f,0x80,0x00,0x80,
    /* ASCII 120 */  0x10,0x80,0x19,0x80,0x06,0x00,0x06,0x00,0x19,0x80,0x10,0x80,0x00,0x00,
    /* ASCII 121 */  0x00,0x80,0x41,0x80,0x46,0x80,0x78,0x00,0x4c,0x80,0x03,0x80,0x00,0x80,
    /* ASCII 122 */  0x00,0x00,0x19,0x80,0x14,0x80,0x12,0x80,0x11,0x80,0x18,0x80,0x00,0x00,
    /* ASCII 123 */  0x00,0x00,0x00,0x00,0x04,0x00,0x3b,0xc0,0x40,0x20,0x00,0x00,0x00,0x00,
    /* ASCII 124 */  0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 125 */  0x00,0x00,0x00,0x00,0x40,0x20,0x3b,0xc0,0x04,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 126 */  0x00,0x00,0x04,0x00,0x02,0x00,0x04,0x00,0x04,0x00,0x02,0x00,0x00,0x00,
    /* ASCII 127 */  0x00,0x00,0x03,0x80,0x02,0x40,0x02,0x20,0x02,0x40,0x03,0x80,0x00,0x00,
    /* ASCII 128 */  0x00,0x00,0x0F,0xC0,0x50,0x20,0x70,0x20,0x10,0x20,0x08,0x60,0x00,0x00,
    /* ASCII 129 */  0x00,0x80,0x0F,0xA0,0x10,0x00,0x10,0x00,0x08,0x80,0x1F,0xA0,0x10,0x00,
    /* ASCII 130 */  0x00,0x00,0x0F,0x00,0x12,0xA0,0x12,0x90,0x12,0x90,0x13,0x00,0x00,0x00,
    /* ASCII 131 */  0x00,0x00,0x0D,0x00,0x12,0xA0,0x12,0x90,0x12,0x90,0x1F,0x20,0x10,0x00,
    /* ASCII 132 */  0x00,0x00,0x0D,0x00,0x12,0xB0,0x12,0x80,0x12,0x80,0x1F,0x30,0x10,0x00,
    /* ASCII 133 */  0x00,0x00,0x0D,0x00,0x12,0x90,0x12,0x90,0x12,0xA0,0x1F,0x00,0x10,0x00,
    /* ASCII 134 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 135 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 136 */  0x00,0x00,0x0F,0x00,0x12,0xA0,0x12,0x90,0x12,0x90,0x13,0x20,0x00,0x00,
    /* ASCII 137 */  0x00,0x00,0x0F,0x00,0x12,0xB0,0x12,0x80,0x12,0x80,0x13,0x30,0x00,0x00,
    /* ASCII 138 */  0x00,0x00,0x0F,0x10,0x12,0x90,0x12,0xB0,0x12,0x80,0x13,0x00,0x00,0x00,
    /* ASCII 139 */  0x00,0x00,0x10,0x08,0x10,0x20,0x1F,0xE0,0x10,0x08,0x10,0x00,0x00,0x00,
    /* ASCII 140 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 141 */  0x00,0x00,0x10,0x00,0x10,0x22,0x1F,0xE4,0x10,0x08,0x10,0x00,0x00,0x00,
    /* ASCII 142 */  0x10,0x00,0x1C,0x00,0x17,0x88,0x04,0x60,0x17,0x88,0x1C,0x00,0x10,0x00,
    /* ASCII 143 */  0x10,0x00,0x1C,0x00,0x17,0x84,0x04,0x6A,0x17,0x84,0x1C,0x00,0x10,0x00,
    /* ASCII 144 */  0x10,0x20,0x1F,0xE0,0x11,0x30,0x13,0xA8,0x10,0x24,0x18,0x60,0x00,0x00,
    /* ASCII 145 */  0x00,0x00,0x0D,0x00,0x15,0x00,0x1F,0x00,0x15,0x00,0x16,0x00,0x00,0x00,
    /* ASCII 146 */  0x00,0x00,0x1F,0x80,0x02,0x40,0x1F,0xC0,0x12,0x40,0x12,0x40,0x00,0x00,
    /* ASCII 147 */  0x00,0x00,0x0F,0x00,0x10,0xA0,0x10,0x90,0x10,0xA0,0x0F,0x00,0x00,0x00,
    /* ASCII 148 */  0x00,0x00,0x0F,0x00,0x10,0xA0,0x10,0x80,0x10,0xA0,0x0F,0x00,0x00,0x00,
    /* ASCII 149 */  0x00,0x00,0x0F,0x00,0x10,0x88,0x10,0x90,0x10,0xA0,0x0F,0x00,0x00,0x00,
    /* ASCII 150 */  0x00,0x80,0x0F,0x80,0x10,0x20,0x10,0x10,0x08,0xA0,0x1F,0x80,0x10,0x00,
    /* ASCII 151 */  0x00,0x80,0x0F,0x90,0x10,0x10,0x10,0x30,0x08,0x80,0x1F,0x80,0x10,0x00,
    /* ASCII 152 */  0x00,0x80,0x41,0x80,0x46,0xA0,0x78,0x00,0x4C,0xA0,0x03,0x80,0x00,0x80,
    /* ASCII 153 */  0x00,0x00,0x0F,0xC0,0x10,0x28,0x10,0x20,0x10,0x28,0x0F,0xC0,0x00,0x00,
    /* ASCII 154 */  0x00,0x20,0x0F,0xE8,0x10,0x20,0x10,0x00,0x10,0x20,0x0F,0xE8,0x00,0x20,
    /* ASCII 155 */  0x00,0x00,0x3F,0x00,0x18,0x80,0x16,0x80,0x11,0x80,0x0F,0xC0,0x00,0x00,
    /* ASCII 156 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 157 */  0x00,0x00,0x3F,0xC0,0x1C,0x20,0x13,0x20,0x10,0xE0,0x0F,0xF0,0x00,0x00,
    /* ASCII 158 */  0x00,0x00,0x08,0x80,0x05,0x00,0x02,0x00,0x05,0x00,0x08,0x80,0x00,0x00,
    /* ASCII 159 */  0x00,0x00,0x20,0x00,0x42,0x00,0x3F,0xE0,0x02,0x10,0x00,0x20,0x00,0x00,
    /* ASCII 160 */  0x00,0x00,0x0D,0x00,0x12,0xA0,0x12,0x90,0x12,0x90,0x1F,0x00,0x10,0x00,
    /* ASCII 161 */  0x00,0x00,0x10,0x00,0x10,0x28,0x1F,0xE4,0x10,0x02,0x10,0x00,0x00,0x00,
    /* ASCII 162 */  0x00,0x00,0x0F,0x00,0x10,0xA0,0x10,0x90,0x10,0x88,0x0F,0x00,0x00,0x00,
    /* ASCII 163 */  0x00,0x20,0x0F,0xE0,0x10,0x28,0x10,0x04,0x10,0x22,0x0F,0xE0,0x00,0x20,
    /* ASCII 164 */  0x10,0x80,0x1F,0x80,0x11,0x20,0x00,0x90,0x10,0xA0,0x1F,0x10,0x10,0x00,
    /* ASCII 165 */  0x10,0x20,0x1F,0xE0,0x10,0xE8,0x07,0x04,0x18,0x28,0x1F,0xE4,0x00,0x20,
    /* ASCII 166 */  0x00,0x00,0x13,0x40,0x14,0xA0,0x14,0xA0,0x14,0xA0,0x17,0xC0,0x14,0x00,
    /* ASCII 167 */  0x00,0x00,0x13,0xC0,0x14,0x20,0x14,0x20,0x14,0x20,0x13,0xC0,0x00,0x00,
    /* ASCII 168 */  0x00,0x00,0x0C,0x00,0x12,0x00,0x11,0x40,0x08,0x40,0x00,0x00,0x00,0x00,
    /* ASCII 169 */  0x0F,0xC0,0x10,0x20,0x17,0x20,0x12,0xA0,0x15,0x20,0x10,0x20,0x0F,0xC0,
    /* ASCII 170 */  0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x18,0x00,0x00,
    /* ASCII 171 */  0x00,0x00,0x05,0xC0,0x02,0x00,0x13,0x00,0x1A,0x80,0x14,0x00,0x00,0x00,
    /* ASCII 172 */  0x00,0x00,0x05,0xC0,0x02,0x00,0x0D,0x00,0x0A,0x80,0x1E,0x00,0x08,0x00,
    /* ASCII 173 */  0x00,0x00,0x0C,0x00,0x1F,0x40,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 174 */  0x00,0x00,0x04,0x00,0x0A,0x00,0x00,0x00,0x04,0x00,0x0A,0x00,0x00,0x00,
    /* ASCII 175 */  0x00,0x00,0x0A,0x00,0x04,0x00,0x00,0x00,0x0A,0x00,0x04,0x00,0x00,0x00,
    /* ASCII 176 */  0x08,0x80,0x02,0x20,0x08,0x80,0x02,0x20,0x08,0x80,0x02,0x20,0x00,0x00,
    /* ASCII 177 */  0x15,0x40,0x0A,0xA0,0x15,0x40,0x0A,0xA0,0x15,0x40,0x0A,0xA0,0x00,0x00,
    /* ASCII 178 */  0x17,0x60,0x1D,0xC0,0x17,0x60,0x1D,0xC0,0x17,0x60,0x1D,0xC0,0x00,0x00,
    /* ASCII 179 */  0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 180 */  0x01,0x00,0x01,0x00,0x01,0x00,0x1F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 181 */  0x10,0x00,0x1C,0x00,0x17,0x90,0x04,0x68,0x17,0x84,0x1C,0x00,0x10,0x00,
    /* ASCII 182 */  0x10,0x00,0x1C,0x10,0x17,0x88,0x04,0x64,0x17,0x88,0x1C,0x10,0x10,0x00,
    /* ASCII 183 */  0x10,0x00,0x1C,0x00,0x17,0x84,0x04,0x68,0x17,0x90,0x1C,0x00,0x10,0x00,
    /* ASCII 184 */  0x0F,0xC0,0x10,0x20,0x17,0xA0,0x14,0xA0,0x14,0xA0,0x10,0x20,0x0F,0xC0,
    /* ASCII 185 */  0x02,0x80,0x02,0x80,0xFE,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,
    /* ASCII 186 */  0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,
    /* ASCII 187 */  0x02,0x80,0x02,0x80,0xFE,0x80,0x00,0x80,0xFF,0x80,0x00,0x00,0x00,0x00,
    /* ASCII 188 */  0x02,0x80,0x02,0x80,0x02,0xFF,0x02,0x00,0x03,0xFF,0x00,0x00,0x00,0x00,
    /* ASCII 189 */  0x00,0x00,0x06,0x00,0x09,0x00,0x19,0x80,0x09,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 190 */  0x00,0x00,0x0A,0x60,0x0A,0x80,0x1F,0x00,0x0A,0x80,0x0A,0x60,0x00,0x00,
    /* ASCII 191 */  0x01,0x00,0x01,0x00,0x01,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 192 */  0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,
    /* ASCII 193 */  0x01,0x00,0x01,0x00,0x01,0x00,0x01,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,
    /* ASCII 194 */  0x01,0x00,0x01,0x00,0x01,0x00,0xFF,0x00,0x01,0x00,0x01,0x00,0x01,0x00,
    /* ASCII 195 */  0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,
    /* ASCII 196 */  0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,
    /* ASCII 197 */  0x01,0x00,0x01,0x00,0x01,0x00,0xFF,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,
    /* ASCII 198 */  0x00,0x00,0x0D,0x20,0x12,0x90,0x12,0xA0,0x12,0x90,0x1F,0x00,0x10,0x00,
    /* ASCII 199 */  0x10,0x00,0x1C,0x00,0x17,0x88,0x04,0x64,0x17,0x88,0x1C,0x04,0x10,0x00,
    /* ASCII 200 */  0x00,0x00,0x00,0x00,0x03,0xFF,0x02,0x00,0x02,0xFF,0x02,0x80,0x02,0x80,
    /* ASCII 201 */  0x00,0x00,0x00,0x00,0xFF,0x80,0x00,0x80,0xFE,0x80,0x02,0x80,0x02,0x80,
    /* ASCII 202 */  0x02,0x80,0x02,0x80,0x02,0xFF,0x02,0x00,0x02,0xFF,0x02,0x80,0x02,0x80,
    /* ASCII 203 */  0x02,0x80,0x02,0x80,0xFE,0x80,0x00,0x80,0xFE,0x80,0x02,0x80,0x02,0x80,
    /* ASCII 204 */  0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFE,0xFF,0x02,0x80,0x02,0x80,
    /* ASCII 205 */  0x02,0x80,0x02,0x80,0x02,0x80,0x02,0x80,0x02,0x80,0x02,0x80,0x02,0x80,
    /* ASCII 206 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 207 */  0x17,0xA0,0x08,0x40,0x08,0x40,0x08,0x40,0x08,0x40,0x17,0xA0,0x00,0x00,
    /* ASCII 208 */  0x00,0x00,0x08,0x80,0x15,0x40,0x16,0x40,0x0C,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 209 */  0x11,0x20,0x1F,0xE0,0x11,0x20,0x10,0x20,0x08,0x40,0x07,0x80,0x00,0x00,
    /* ASCII 210 */  0x10,0x20,0x1F,0xE0,0x11,0x30,0x13,0xA8,0x10,0x30,0x18,0x60,0x00,0x00,
    /* ASCII 211 */  0x10,0x20,0x1F,0xE0,0x11,0x28,0x13,0xA0,0x10,0x28,0x18,0x60,0x00,0x00,
    /* ASCII 212 */  0x10,0x20,0x1F,0xE0,0x11,0x24,0x13,0xA8,0x10,0x30,0x18,0x60,0x00,0x00,
    /* ASCII 213 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 214 */  0x00,0x00,0x10,0x20,0x10,0x20,0x1F,0xF0,0x10,0x28,0x10,0x24,0x00,0x00,
    /* ASCII 215 */  0x00,0x00,0x10,0x30,0x10,0x28,0x1F,0xE4,0x10,0x28,0x10,0x30,0x00,0x00,
    /* ASCII 216 */  0x00,0x00,0x10,0x20,0x10,0x28,0x1F,0xE0,0x10,0x28,0x10,0x20,0x00,0x00,
    /* ASCII 217 */  0x01,0x00,0x01,0x00,0x01,0x00,0x01,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 218 */  0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x01,0x00,0x01,0x00,0x01,0x00,
    /* ASCII 219 */  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    /* ASCII 220 */  0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,
    /* ASCII 221 */  0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 222 */  0x00,0x00,0x10,0x24,0x10,0x28,0x1F,0xF0,0x10,0x20,0x10,0x20,0x00,0x00,
    /* ASCII 223 */  0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,
    /* ASCII 224 */  0x00,0x00,0x0F,0xC0,0x10,0x20,0x10,0x30,0x10,0x28,0x0F,0xC0,0x00,0x00,
    /* ASCII 225 */  0x00,0x00,0x7F,0xE0,0x11,0x20,0x11,0x20,0x11,0x20,0x0E,0xC0,0x00,0x00,
    /* ASCII 226 */  0x00,0x00,0x0F,0xC0,0x10,0x28,0x10,0x24,0x10,0x28,0x0F,0xC0,0x00,0x00,
    /* ASCII 227 */  0x00,0x00,0x0F,0xC0,0x10,0x28,0x10,0x30,0x10,0x20,0x0F,0xC0,0x00,0x00,
    /* ASCII 228 */  0x00,0x00,0x0F,0x00,0x10,0xA0,0x10,0x90,0x10,0xA0,0x0F,0x10,0x00,0x00,
    /* ASCII 229 */  0x00,0x00,0x0F,0xC0,0x10,0x28,0x10,0x24,0x10,0x28,0x0F,0xC4,0x00,0x00,
    /* ASCII 230 */  0x40,0x80,0x3F,0x80,0x10,0x00,0x10,0x00,0x08,0x80,0x1F,0x80,0x10,0x00,
    /* ASCII 231 */  0x00,0x00,0x1F,0xC0,0x15,0x40,0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 232 */  0x00,0x00,0x1F,0xE0,0x14,0xA0,0x04,0x80,0x03,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 233 */  0x00,0x20,0x0F,0xE0,0x10,0x20,0x10,0x0C,0x10,0x24,0x0F,0xE4,0x00,0x20,
    /* ASCII 234 */  0x00,0x20,0x0F,0xE0,0x10,0x28,0x10,0x04,0x10,0x28,0x0F,0xE0,0x00,0x20,
    /* ASCII 235 */  0x00,0x20,0x0F,0xE4,0x10,0x24,0x10,0x0C,0x10,0x20,0x0F,0xE0,0x00,0x20,
    /* ASCII 236 */  0x00,0x80,0x41,0x80,0x46,0xA0,0x78,0x10,0x4C,0x88,0x03,0x80,0x00,0x80,
    /* ASCII 237 */  0x00,0x20,0x00,0x60,0x11,0xA0,0x1E,0x10,0x11,0xA8,0x00,0x64,0x00,0x20,
    /* ASCII 228 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 239 */  0x00,0x00,0x00,0x04,0x00,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 240 */  0x00,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x00,0x00,
    /* ASCII 241 */  0x00,0x00,0x11,0x00,0x11,0x00,0x17,0xC0,0x11,0x00,0x11,0x00,0x00,0x00,
    /* ASCII 242 */  0xA0,0x00,0xA0,0x00,0xA0,0x00,0xA0,0x00,0xA0,0x00,0xA0,0x00,0xA0,0x00,
    /* ASCII 243 */  0x02,0x20,0x06,0xA0,0x03,0xE0,0x0D,0x00,0x0A,0x80,0x1E,0x00,0x08,0x00,
    /* ASCII 244 */  0x00,0x00,0x00,0xC0,0x01,0x20,0x1F,0xE0,0x00,0x20,0x1F,0xE0,0x00,0x00,
    /* ASCII 245 */  0x00,0x00,0x0C,0x38,0x10,0xC4,0x11,0x44,0x11,0x84,0x0E,0x18,0x00,0x00,
    /* ASCII 246 */  0x00,0x00,0x02,0x00,0x02,0x00,0x0A,0x80,0x02,0x00,0x02,0x00,0x00,0x00,
    /* ASCII 247 */  0x00,0x00,0x80,0x00,0x60,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 248 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x00,
    /* ASCII 249 */  0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
    /* ASCII 250 */  0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 251 */  0x00,0x00,0x01,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 252 */  0x00,0x00,0x02,0xA0,0x03,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 253 */  0x00,0x00,0x02,0x40,0x03,0x20,0x02,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
    /* ASCII 254 */  0x00,0x00,0x0F,0x80,0x0F,0x80,0x0F,0x80,0x0F,0x80,0x0F,0x80,0x00,0x00,
    /* ASCII 255 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

static const u8 UW_Icon[4*32]	= 	{ /* Will be set to any NULL Icon	*/
	0xFF,0xFF,0xFF,0x00,
	0xFF,0xFF,0xFF,0x00,
	0xFD,0xFF,0xFF,0x00,
	0xFD,0xFF,0xFF,0x00,
	0xFD,0xC7,0xFF,0x00,
	0xFD,0x80,0xFF,0x00,
	0xFD,0x80,0x1F,0x00,
	0xFD,0x80,0x1F,0x00,
	0xFD,0x98,0x1F,0x00,
	0xFD,0x8F,0x1F,0x00,
	0xFD,0x87,0xFF,0x00,
	0xFD,0xC0,0xFF,0x00,
	0xFD,0xC0,0x1F,0x00,
	0xFD,0xE0,0x1F,0x00,
	0xFD,0xF8,0x1F,0x00,
	0xFD,0xFF,0x1F,0x00,
	0xFD,0x80,0xFF,0x00,
	0xFD,0x80,0x1F,0x00,
	0xFD,0x80,0x1F,0x00,
	0xFD,0x80,0x1F,0x00,	
	0xFD,0xC0,0x1F,0x00,
	0xFD,0xF0,0x7F,0x00,
	0xFD,0x80,0x1F,0x00,
	0xFD,0x80,0x1F,0x00,
	0xFD,0x80,0x1F,0x00,
	0xFD,0x80,0x1F,0x00,
	0xFD,0xC0,0x7F,0x00,
	0xFD,0xF0,0x1F,0x00,
	0xFF,0xFC,0x1F,0x00,
	0xFF,0xFF,0x1F,0x00,
	0xFF,0xFF,0x9F,0x00,
	0xFF,0xFF,0xFF,0x00
	};
            

void swap(u32 *a, u32 *b)
{
	u32 c;
	c=*a;
	*a=*b;
	*b=c;
}
			

#ifdef	SHOW_CURSOR
/*!
 * \brief Show Touch Screen Position
 *
 * This function will draw a cursor on the position of Touch screen
 *
 * \param[in] x : X position of last touch
 * \param[in] y : Y position of last touch
 * \return none 
 */
static void UW_DrawCursor(u8 x, u8 y)
{
	#define	CURSOR_SIZE	3
	if ((x>127) || (y>127))
		return;
	u8	startx,endx,starty,endy;
	startx 	= (x > CURSOR_SIZE) ? (x-CURSOR_SIZE):0;
	endx  	= (x < (127-(CURSOR_SIZE))) ? (x+(CURSOR_SIZE)):127;
	starty 	= (y > CURSOR_SIZE) ? (y-CURSOR_SIZE):0;
	endy  	= (y < (127-(CURSOR_SIZE))) ? (y+(CURSOR_SIZE)):127;;
	if ((startx> 128) || (endx > 128) || (starty > 128) || (endy>128))
			return;
	//LCD_FillRect(startx,y,(endx-startx+1),1,RED);
	//LCD_FillRect(x,starty,1,(endy-starty+1),RED);
}
#endif

/*!
 * \brief API to add a new UWindow
 *
 * This function will :
 *			add a new UWindow Objet to pParent
 * 			do all nessecary and default initializations
 *			attach the New Window to its extra properties if available
 *
 * \param[in] pWindow 	: Pointer to new window object
 * \param[in] Type 		: Type of the new windows
 * \param[in] pParent	: Ponter to Parent window
 * \param[in] ExtraProperties	: Pointer to Extra properties object
 * \return none 
 */
void UW_Add(UW_Window * pWindow, UW_Type Type, UW_Window * pParent, void * ExtraProperties)
{
	u8	length, height;
	switch (Type)
	{
		case (UW_FORM):
			length	= DEFAULT_FORM_LENGTH;
			height	= DEFAULT_FORM_HEIGHT;
			break;
		case (UW_EDIT):
			length	= DEFAULT_EDIT_LENGTH;
			height	= DEFAULT_EDIT_HEIGHT;
			break;
		case (UW_LABEL):
			length	= DEFAULT_LABEL_LENGTH;
			height	= DEFAULT_LABEL_HEIGHT;
			break;
		case (UW_CHECKBOX):
			length	= DEFAULT_CHECK_LENGTH;
			height	= DEFAULT_CHECK_HEIGHT;
			break;
		case (UW_BUTTON):
			length	= DEFAULT_BTN_LENGTH;
			height	= DEFAULT_BTN_HEIGHT;
			break;
		case (UW_LISTBOX):
			{
			UW_ListBox * 	Properties;
			length	= DEFAULT_LIST_LENGTH;
			height	= DEFAULT_LIST_HEIGHT;
			pWindow->ExtraProperties	= ExtraProperties;
			Properties = (UW_ListBox *) pWindow->ExtraProperties;
			Properties->ActiveItem	= NULL;
			Properties->StartItem  	= NULL;
            Properties->ItemsCount  = 0;
			Properties->ItemHeight	= 25;
			INIT_LIST_HEAD(&Properties->items);
			}
			break;
		case (UW_ICON):
			length	= DEFAULT_ICON_LENGTH;
			height	= DEFAULT_ICON_HEIGHT;
			if (ExtraProperties != NULL)
				pWindow->ExtraProperties	= ExtraProperties;
			else
				pWindow->ExtraProperties	= (void *)UW_Icon;
			break;	
		case (UW_FADER):
			length	= DEFAULT_FADER_LENGTH;
			height	= DEFAULT_FADER_HEIGHT;
			break;
		case (UW_POT):
			length	= DEFAULT_POT_LENGTH;
			height	= DEFAULT_POT_HEIGHT;
			break;
		
	}
	pWindow->type			= Type;	
	pWindow->Absx			= 0;
	pWindow->Absy			= 0;
    	pWindow->length   		= length;
    	pWindow->height   		= height;
    	pWindow->visible  		= 1;
		pWindow->enable			= 1;
    	pWindow->value			= 0;
	pWindow->CallBacks.Click 	= NULL;
	pWindow->CallBacks.ButtonPress	= NULL;
	pWindow->CallBacks.TimerCallBack.Timer	= NULL;
	pWindow->caption 		= NULL;
	pWindow->captionlen 		= 0;
	INIT_LIST_HEAD(&pWindow->items);
	if (pWindow->type == UW_ICON)
		list_add(&pWindow->node,&pParent->items);
	else
		list_add_tail(&pWindow->node,&pParent->items);
	Refresh					= 1;
}

/*!
 * \brief Reassign Colors to a fixed smaller list
 *
 * all the UWindow is drawn to memory first 
 * to reduce the size of memory colors allowed to each pixel are reduced
 *
 * \param[in] color : colored assigned by user
 *
 * \return actual colored used
 */
static u8 UW_ReduceColor(u16 color)
{
	if (color < BLUE)
		return SIMPLE_BLACK;
	if (color > GRAY)
		return SIMPLE_WHITE;
	if (color == BLUE)
		return SIMPLE_BLUE;
	return SIMPLE_GRAY;	
}

/*!
 * \brief set pixel value in Image
 *
 * This function will set the value of the pixel in memory
 * to be mapped later to LCD
 *
 * \param[in] x : X position of pixel
 * \param[in] y : Y position of pixel
 * \param[in] color : color assigned by user
 * \return none 
 */
static void UW_SetPixel(s32 x, s32 y, u8 color)
{
#ifdef _MIOS32_CONFIG_H
  switch( UWBitmap.colour_depth ) {
    case 2:
      MIOS32_LCD_BitmapPixelSet(UWBitmap, x, APP_LCD_HEIGHT-y-1, color);
      break;

    default: // 1 and others
      MIOS32_LCD_BitmapPixelSet(UWBitmap, x, APP_LCD_HEIGHT-y-1, (color >= 2) ? 0 : 1);
      break;
  }
#else
	s32 index;
	u8	AndMask,ValMask;
	if ( ((x < MAX_X) && (x >= 0))&& ((y<MAX_Y) && (y >=0)))
	{
		index = (y * 40) + (x >> 2);
		switch (x%4)
		{
			case 0:
				AndMask	= 0xFC;
				ValMask	= (color&0x3);
				break;
			case 1:
				AndMask	= 0xF3;
				ValMask	= (color&0x3)<<2;
				break;
			case 2:
				AndMask	= 0xCF;
				ValMask	= (color&0x3)<<4;
				break;
			case 3:
				AndMask	= 0x3F;
				ValMask	= (color&0x3)<<6;
				break;
				
		}
		UWImage[index] &= AndMask;
		UWImage[index] |= ValMask;
	}
#endif
}

/*!
 * \brief apply image to LCD
 *
 * This function will apply the final UWindows Image to LCD
 *
 * \return none 
 */
static void UW_DrawImage(void)
{
#ifdef _MIOS32_CONFIG_H
  MIOS32_LCD_CursorSet(0, 0);
  MIOS32_LCD_BitmapPrint(UWBitmap);
#else
	u32	index=0;
	for (index=0; index<(4096); index++)
	{
		u8 x,y;
		u16	color;
		y = (u8) (index>>5);
		x = ((u8)(index%32))*4;
		color = UWImage[index] & 0x3;
		LCD_DrawPixel(x, y, Colors[color]);
		x++;
		color = (UWImage[index]>>2) & 0x03;
		LCD_DrawPixel(x, y, Colors[color]);
		x++;
		color = (UWImage[index]>>4) & 0x03;
		LCD_DrawPixel(x, y, Colors[color]);
		x++;
		color = (UWImage[index]>>6) & 0x03;
		LCD_DrawPixel(x, y, Colors[color]);		
	}	
#endif
}

/*!
 * \brief Draw a rectangle to Image
 *
 * This function will Draw a shaded rectangle in memory
 *
 * \param[in] x : X start of Rectangle
 * \param[in] y : Y start of Rectangle
 * \param[in] length : length of Rectangle
 * \param[in] hieght : height of Rectangle 
 * \param[in] color : color assigned by user
 * \return none 
 */
static void UW_FillRect(s32 x,s32 y,s32 length,s32 height, u16 color)
{
	s32 xindex,yindex;
	u8 u8simplecolor;
	u8simplecolor = UW_ReduceColor(color);
	for(yindex=y; yindex<(y+height); yindex++)
		for(xindex=x; xindex<(x+length); xindex++)		
			UW_SetPixel(xindex, yindex, u8simplecolor);
}

/*!
 * \brief Draw a triangle to Image
 *
 * This function will Draw a triangle in memory
 *
 * \param[in] x : X start of Rectangle
 * \param[in] y : Y start of Rectangle
 * \param[in] length : length of Triangle
 * \param[in] direct : up or down
 * \param[in] color : color assigned by user
 * \return none 
 */
static void UW_FillTriangle(s32 x,s32 y,s32 length,s32 direction,u16 color)
{
	s32 xindex,yindex;
	u8 	u8simplecolor;
	xindex = x;
	yindex = y;
	u8simplecolor = UW_ReduceColor(color);
	while (length > 0)
	{
		for(xindex=x; xindex<x+length; xindex++)		
			UW_SetPixel(xindex, yindex, u8simplecolor);
		if (length >1)
			length -= 2;
		else
			length--;
		if (direction == 1)
			yindex++;
		else
			yindex--;
		x++;
	}
}

/*!
 * \brief Draw a Circle to Image
 *
 * This function will Draw a blank circle in memory
 * 
 * \param[in] xpos : X position of centre of circle
 * \param[in] ypos : Y position of centre of circle
 * \param[in] r : Radius of circle
 * \param[in] color : color assigned by user
 * \return none 
 */
static void UW_DrawCircle(s32 xpos, s32 ypos, s32 r, u16 color)
{
	int x=0,y=r;
	while (x <= y)
    {
        // We make use of 8 axes of symmetry in a circle.
        // This way we have fewer points to calculate on its circumference.
        UW_SetPixel(xpos + x, ypos + y, color);
        UW_SetPixel(xpos - x, ypos + y, color);
        UW_SetPixel(xpos + x, ypos - y, color);
        UW_SetPixel(xpos - x, ypos - y, color);
        UW_SetPixel(xpos + y, ypos + x, color);
        UW_SetPixel(xpos - y, ypos + x, color);
        UW_SetPixel(xpos + y, ypos - x, color);
        UW_SetPixel(xpos - y, ypos - x, color);

        // This is the most important part of the function.
        // We go to the right in all cases (x++).
        // We need to decide whether to go down (y--).
        // This depends on which point is
        // closest to the path of the circle.
        // Good old Pythagoras will tell us what to do.
        x++;
        if (abs (x*x + y*y - r*r) > abs (x*x + (y-1)*(y-1) - r*r))
			y--;
    }

}



void UW_DrawLine(s32 x1, s32 y1, s32 x2, s32 y2,u16 color)
{
	u8 x, y;
	signed int a, c;
	signed int b;
		
	// Calculate the coefficients.
	a = y1-y2;
	b = x1*y2-y1*x2;
	c = x1-x2;


	// Horizontal Line
	if (c==0) {
		if (y1>y2) swap(&y1, &y2);
		for(y=y1; y<=y2; y++)
		{
			UW_SetPixel(x1, y,color);
		}
		return;
	}

	// Vertical Line
	if (a==0) {
		if (x1>x2) swap(&x1, &x2);
		for(x=x1; x<=x2; x++) 
		{
			UW_SetPixel(x, y1,color);
		}
		return;
	}
	
	// line y=(ax+b)/c
	if (abs(c) >= abs(a)) {// Delta x > Delta y
		if (x1>x2) {
			swap(&x1, &x2);
			swap(&y1, &y2);	
		}
		for(x=x1; x<=x2; x++){
			y = (a*x+b)/c;
			UW_SetPixel(x, y,color);
		}	
	}
	// line x = (y*c-b)/a
	else {	// Delta y > Delta x
		if (y1>y2) {
			swap(&x1, &x2);
			swap(&y1, &y2);				
		}
		for(y=y1; y<=y2; y++){
			x = (y*c-b)/a;
			UW_SetPixel(x, y,color);
		}	
	}
}






/*!
 * \brief Draw a rectangle to Image
 *
 * This function will Draw a blank rectangle in memory
 *
 * \param[in] x : X start of Rectangle
 * \param[in] y : Y start of Rectangle
 * \param[in] length : length of Rectangle
 * \param[in] height : height of Rectangle 
 * \param[in] color : color assigned by user
 * \return none 
 */
static void UW_DrawRect( s32 x, s32 y, s32 width, s32 height, u16 color )
{
        // Draw horizontal sides.
        UW_FillRect( x, y,              width, 1, color );
        UW_FillRect( x, y + height - 1, width, 1, color );

        // Draw vertical sides.
        UW_FillRect( x,              y, 1, height, color );
        UW_FillRect( x + width - 1,  y, 1, height, color );
}

/*!
 * \brief Draw a character to Image
 *
 * This function will Draw a single character in memory
 *
 * \param[in] x : X start of character
 * \param[in] y : Y start of character
 * \param[in] fontcolor : color assigned by user to font
 * \param[in] bgndcolor : color assigned by user to background
 * \return none 
 */
static void UW_DrawChar(s32 x,s32 y,u8 chr,u8 fontcolor,u8 bgndColor)
{
	//u8 firstbyte = CurrentFont[0];	

	u16 index;
	s32 xp,yp;
	u8 mask;
	index = (chr -32)*14;
	for (xp=x;xp<(x+7);xp++)
	{
		mask = 0x80;
		for (yp=y;yp<(y+8);yp++)
		{
			if (CurrentFont[index] & mask)
				UW_SetPixel(xp, yp, fontcolor);
			else
				UW_SetPixel(xp, yp, bgndColor);
			mask >>= 1;
		}
		index++;
		mask = 0x80;
		for (yp=y+8;yp<(y+16);yp++)
		{
			if (CurrentFont[index] & mask)
				UW_SetPixel(xp, yp, fontcolor);
			else
				UW_SetPixel(xp, yp, bgndColor);
			mask >>= 1;
		}
		index++;
	}
	
	return;
}


/*!
 * \brief Handler to  Timer call backs
 *
 * This function will handle timer callbacks for all object
 *
 * \param[in] pstrItem : pointer to UW_Window Object
 * \return none 
 */
static void UW_HandleTimer(UW_Window * pstrItem)
{
	struct list_head	* pos;
	UW_Window		    * pstrtmpitem;
	if ((pstrItem->visible == 0) || (pstrItem->enable == 0))
		return;
	if (pstrItem->CallBacks.TimerCallBack.Timer != NULL)
	{
		pstrItem->CallBacks.TimerCallBack.u32CurrentTime++;
		if (pstrItem->CallBacks.TimerCallBack.u32CurrentTime == pstrItem->CallBacks.TimerCallBack.u32TimeOut)
		{
			pstrItem->CallBacks.TimerCallBack.Timer(pstrItem);	
			pstrItem->CallBacks.TimerCallBack.u32CurrentTime = 0;
		}
	}	
	list_for_each(pos, &pstrItem->items)
	{
		pstrtmpitem = list_entry(pos, UW_Window, node);
	    if ((pstrtmpitem->visible == 1) && (pstrtmpitem->enable == 1))
			UW_HandleTimer(pstrtmpitem);
	}
}

/*!
 * \brief Draw a string to Image
 *
 * This function will Draw a string in memory
 *
 * \param[in] x : X start of string
 * \param[in] y : Y start of string
 * \param[in] ptr: pointer to array of character
 * \param[in] len: length of array
 * \param[in] fontcolor : color assigned by user to font
 * \param[in] bgndcolor : color assigned by user to background
 * \return none 
 */
static void UW_DisplayString( s32 x, s32 y, const u8* ptr, u8 len,u16 fontcolor,u16 bgndcolor)
{
    u8  i = 0, c;
	s32 ref_x = x;
	u8 u8bgndcolor, u8fontcolor;
	u8fontcolor = UW_ReduceColor(fontcolor);
	u8bgndcolor = UW_ReduceColor(bgndcolor);
    	/* Display each character on LCD */
	for ( i = 0 ; i < len ; i++ )
	{
		c = *ptr;
		if ( c )
		{
			ptr++;      /* Point to the next character */
		}
		else
		{            
			c = ' ';    /* fill with space when len exceeds strlen(ptr) */            
		}
	        /* Display one character on LCD */
	        UW_DrawChar(ref_x, y, c, u8fontcolor, u8bgndcolor);	       
		/* Increment the column position by 7 */
		ref_x+= (CH_WIDTH );
        }
}

/*!
 * \brief Draw a string to Image
 *
 * This function will Draw a string in memory within certain size
 *
 * \param[in] x : X start of string
 * \param[in] y : Y start of string
 * \param[in] ptr: pointer to array of character
 * \param[in] len: length of array
 * \param[in] fontcolor : color assigned by user to font
 * \param[in] bgndcolor : color assigned by user to background
 * \param[in] length	: maximum allowed width
 * \param[in] height	: maximum allowed height
 * \return none 
 */
static void UW_DisplayString_InSize( s32 x, s32 y, const u8* ptr, u8 len,u16 fontcolor,u16 bgndcolor,s32 length,s32 height)
{
	u8  i = 0, c;
	s32 ref_x = x,ref_y;
	u8 u8bgndcolor, u8fontcolor;
	u8fontcolor = UW_ReduceColor(fontcolor);
	u8bgndcolor = UW_ReduceColor(bgndcolor);
    
	if ((height < (CH_HEIGHT)) || (length < CH_WIDTH))
			return;
	ref_y = y+height-CH_HEIGHT;
	/* Display each character on LCD */
	for ( i = 0 ; i < len ; i++ )
	{
		if ((ref_x+CH_WIDTH) > (x+length))
		{
			if ((ref_y-CH_HEIGHT) > y)
			{
				ref_x = x;
				ref_y -= CH_HEIGHT;
			}
			else
				return;
		}
		c = *ptr;
		if ( c )
		{
			ptr++;      /* Point to the next character */
		}
		else
		{
			c = ' ';    /* fill with space when len exceeds strlen(ptr) */
		}
        	/* Display one character on LCD */
		UW_DrawChar(ref_x, ref_y, c, u8fontcolor, u8bgndcolor);
		/* Increment the column position by 7 */
		ref_x+= (CH_WIDTH );
        }
}

/*!
 * \brief Draw Icon object to Image
 *
 * This how UWindows handle Icons in memory
 *
 * \param[in] pIcom: pointer to UWindow Object treated as Icon
 * \return none 
 */
static void UW_DrawIcon(UW_Window * pIcon)
{
	u8 index=0,mask;
	s32 px,py,x,y;
	u8 * IconImage;
	x = pIcon->Absx;
	y = pIcon->Absy;
	pIcon->length	= 32;
	pIcon->height	= 32;
	IconImage = (u8 *)pIcon->ExtraProperties;
	if (pIcon->captionlen > 0)
	{
		UW_DisplayString_InSize(x,y,pIcon->caption,pIcon->captionlen,WHITE,BLUE,32,16);
		y += 16;
		pIcon->height += 16;
	}	
	for (px=0; px < 32; px++)
	{
		mask = 0x80;
		for(py=0; py<8;py++)
		{
			if (IconImage[index] & mask)
				UW_SetPixel(x+px, y+py, SIMPLE_BLACK);				
			else
				UW_SetPixel(x+px, y+py, SIMPLE_WHITE);	
			mask >>= 1;
		}
		index++;
		mask = 0x80;
		for(py=8; py<16;py++)
		{
			if (IconImage[index] & mask)
				UW_SetPixel(x+px, y+py, SIMPLE_BLACK);				
			else
				UW_SetPixel(x+px, y+py, SIMPLE_WHITE);		
			mask >>= 1;
		}
		index++;
		mask = 0x80;
		for(py=16; py<24;py++)
		{
			if (IconImage[index] & mask)
				UW_SetPixel(x+px, y+py, SIMPLE_BLACK);				
			else
				UW_SetPixel(x+px, y+py, SIMPLE_WHITE);	
			mask >>= 1;
		}
		index++;
		mask = 0x80;
		for(py=24; py<32;py++)
		{
			if (IconImage[index] & mask)
				UW_SetPixel(x+px, y+py, SIMPLE_BLACK);				
			else
				UW_SetPixel(x+px, y+py, SIMPLE_WHITE);	
			mask >>= 1;
		}
		index++;		
	}
}

/*!
 * \brief Draw ListBox object to Image
 *
 * This how UWindows handle ListBox in memory
 *
 * \param[in] ListBox: pointer to UWindow Object treated as ListBox
 * \return none 
 */
static void UW_DrawListBox(UW_Window * ListBox)
{
	u8 BtnWidth,BtnHeight;	
	u8 index;
	s32 xindex,yindex;
	struct list_head	* pos;
	UW_Window	* pstrtmpitem;
	UW_ListBox	* Properties = ListBox->ExtraProperties;
	BtnWidth = 20;
	BtnHeight = (u8) (ListBox->height / 2);
	xindex	= ListBox->Absx;
	yindex	= ListBox->Absy;
	UW_FillRect(ListBox->Absx+1,ListBox->Absy+1,ListBox->length-2,ListBox->height-2,WHITE);
	UW_DrawRect(ListBox->Absx,ListBox->Absy,ListBox->length,ListBox->height,GRAY);
	Properties->BtnDwn.Absx 	= ListBox->Absx + ListBox->length - BtnWidth;
	Properties->BtnDwn.Absy 	= ListBox->Absy;
	Properties->BtnDwn.length	= BtnWidth;
	Properties->BtnDwn.height	= BtnHeight;
	Properties->BtnDwn.visible	= 1;
	Properties->BtnDwn.enable	= 1;
	INIT_LIST_HEAD(&Properties->BtnDwn.items);
	Properties->BtnUp.Absx 	= ListBox->Absx + ListBox->length - BtnWidth;
	Properties->BtnUp.Absy 	= ListBox->Absy+ListBox->height-BtnHeight;
	Properties->BtnUp.length	= BtnWidth;
	Properties->BtnUp.height	= BtnHeight;
	Properties->BtnUp.visible	= 1;
	Properties->BtnUp.enable	= 1;
	INIT_LIST_HEAD(&Properties->BtnUp.items);
	UW_DrawItem(&Properties->BtnUp);
	UW_DrawItem(&Properties->BtnDwn);
	UW_FillTriangle(Properties->BtnUp.Absx+4, Properties->BtnUp.Absy+4, 9, 1, GRAY);
	UW_FillTriangle(Properties->BtnDwn.Absx+4, Properties->BtnDwn.Absy+Properties->BtnDwn.height-4, 9, 0, GRAY);	
	/**/
	yindex	= ListBox->Absy + ListBox->height - Properties->ItemHeight;
	index = 0;
	list_for_each(pos, &Properties->items)
	{
		pstrtmpitem = list_entry(pos, UW_Window, node);
		pstrtmpitem->type		= UW_EDIT;	
		pstrtmpitem->length	= ListBox->length - BtnWidth;
		pstrtmpitem->height	= Properties->ItemHeight;
		if (pstrtmpitem == Properties->StartItem)
			index++;
		if (index > 0)
		{
			pstrtmpitem->Absx 	= xindex;
			pstrtmpitem->Absy 	= yindex;		
			pstrtmpitem->visible	= 1;
			yindex -= (Properties->ItemHeight+1);
			UW_DrawItem(pstrtmpitem);
			if (pstrtmpitem == Properties->ActiveItem)
				UW_DrawRect(pstrtmpitem->Absx,pstrtmpitem->Absy, pstrtmpitem->length, pstrtmpitem->height, BLUE);
		
		}
		else
		{
			pstrtmpitem->Absx 	= 0;
			pstrtmpitem->Absy 	= 0;		
			pstrtmpitem->visible	= 0;
		}
      	if ((yindex < ListBox->Absy) ||(yindex > MAX_X))
			break;
		//index++;
	}
	
}

/*!
 * \brief Drawing object to Image
 *
 * This how UWindows handle most of objects in memory
 *
 * \param[in] pstrItem: pointer to UWindow Object
 * \return none 
 */
static void UW_DrawItem(UW_Window * pstrItem)
{
	struct list_head *	pos;
	UW_Window * 	pstrtmpitem;	
	if ((pstrItem->visible == 0) 
		/*
	
        ||  (pstrItem->Absx > 128) 
        ||  (pstrItem->Absy > 128)
		*/
	)
		return;
	if  (pstrItem->type == UW_LABEL)
	{
		UW_DisplayString(pstrItem->Absx, pstrItem->Absy, pstrItem->caption, pstrItem->captionlen,BLACK,WHITE);
	}
	else if ( (pstrItem->type == UW_BUTTON) || (pstrItem->type == UW_EDIT))
	{
		UW_FillRect(pstrItem->Absx+1,pstrItem->Absy+1,pstrItem->length-2,pstrItem->height-2,WHITE);
       	UW_DisplayString_InSize(pstrItem->Absx+1, pstrItem->Absy, pstrItem->caption, pstrItem->captionlen,GRAY,WHITE,pstrItem->length-2,pstrItem->height);	   
		if (pstrItem == pUW_Infocus)
		{
			UW_DrawRect(pstrItem->Absx,pstrItem->Absy,pstrItem->length,pstrItem->height,BLUE); 
			UW_DrawRect(pstrItem->Absx+1,pstrItem->Absy+1,pstrItem->length-2,pstrItem->height-2,GRAY);
		}
		else
			UW_DrawRect(pstrItem->Absx,pstrItem->Absy,pstrItem->length,pstrItem->height,GRAY);    		        
	}
	else if  (pstrItem->type == UW_CHECKBOX)
	{
		UW_DrawRect(pstrItem->Absx,pstrItem->Absy,10,pstrItem->height,GRAY);
		if (pstrItem->value != 0)            
			UW_FillRect(pstrItem->Absx+1,pstrItem->Absy+1,8,pstrItem->height-2,BLACK);		
		else
			UW_FillRect(pstrItem->Absx+1,pstrItem->Absy+1,8,pstrItem->height-2,WHITE);		
		UW_DisplayString(pstrItem->Absx+10+1, pstrItem->Absy+1, pstrItem->caption, pstrItem->captionlen,GRAY,WHITE);
	}
	else if   (pstrItem->type == UW_FORM)
	{
		UW_FillRect(pstrItem->Absx+1,pstrItem->Absy+1,pstrItem->length-2,pstrItem->height-2,WHITE);
		UW_DrawRect(pstrItem->Absx,pstrItem->Absy,pstrItem->length,pstrItem->height,GRAY);
		if (pstrItem->captionlen != 0)
		{
			UW_FillRect(pstrItem->Absx,pstrItem->Absy+pstrItem->height-15,pstrItem->length,15,BLUE);
			UW_DisplayString(pstrItem->Absx+1, pstrItem->Absy+pstrItem->height-15, pstrItem->caption, pstrItem->captionlen,WHITE,BLUE);
		}	  
	}
	else if   (pstrItem->type == UW_ICON)
	{
    		UW_DrawIcon(pstrItem);
    	}
	else if (pstrItem->type == UW_LISTBOX)
	{
		UW_DrawListBox(pstrItem);
	}		
	else if (pstrItem->type == UW_FADER)
	{
			UW_DrawRect(pstrItem->Absx,pstrItem->Absy,pstrItem->length,pstrItem->height,BLACK);    		        
			UW_FillRect(pstrItem->Absx+1,pstrItem->Absy+1,pstrItem->length-2,((pstrItem->height-2)*pstrItem->value)/256,BLUE);		
	}		
	else if (pstrItem->type == UW_POT)
	{
			UW_DrawCircle(pstrItem->Absx,pstrItem->Absy,pstrItem->length,BLACK); 
			UW_DrawLine(pstrItem->Absx,pstrItem->Absy, pstrItem->Absx+(pstrItem->length>>1), pstrItem->Absy+(pstrItem->length>>1),BLACK);
	}		
	else if (pstrItem->type == UW_ENVELOPE)
	{
	  UW_DrawRect(pstrItem->Absx, pstrItem->Absy, pstrItem->length, pstrItem->height, BLACK);

	  int offsetX = pstrItem->Absx + (pstrItem->length-4*2*16)/2;
	  int offsetY = pstrItem->Absy + (pstrItem->height-2*16)/2;
	  int envA = (pstrItem->value >>  0) & 0xf;
	  int envD = (pstrItem->value >>  4) & 0xf;
	  int envS = (pstrItem->value >>  8) & 0xf;
	  int envR = (pstrItem->value >> 12) & 0xf;

	  int aOffsetX = offsetX + envA*2;
	  int aOffsetY = offsetY + 16*2;
	  int dOffsetX = aOffsetX + envD*2;
	  int dOffsetY = offsetY + envS*2;
	  int sOffsetX = dOffsetX + 2*16;
	  int sOffsetY = dOffsetY;
	  int rOffsetX = sOffsetX + envR*2;
	  int rOffsetY = offsetY;

	  UW_DrawLine(offsetX, offsetY, aOffsetX, aOffsetY, BLUE);
	  UW_DrawLine(aOffsetX, aOffsetY, dOffsetX, dOffsetY, BLUE);
	  UW_DrawLine(dOffsetX, dOffsetY, sOffsetX, sOffsetY, BLUE);
	  UW_DrawLine(sOffsetX, sOffsetY, rOffsetX, rOffsetY, BLUE);
	}		
	
	list_for_each(pos, &pstrItem->items)
	{
		pstrtmpitem = list_entry(pos, UW_Window, node);
        	if (pstrtmpitem->visible == 1)
            		UW_DrawItem(pstrtmpitem);
	}    
}

/*!
 * \brief detect Item clicked
 *
 * using X and Y coordinates and visible object detemine which object was clicked
 *
 * \param[in] pstrItem: pointer to UWindow Object
 * \param[out] pstrClick: pointer to pointer to the object clicked
 * \param[in] x: X location of click
 * \param[in] y: Y location of click
 * \return none 
 */
static void UW_GetItemClicked(UW_Window * pstrItem, UW_Window * * pstrClickedItem,u8 x, u8 y)
{
	struct list_head	* pos;
	UW_Window		    * pstrtmpitem;
	if ((pstrItem->visible == 0) || (pstrItem->enable == 0))
		return;
	if (	(x>=pstrItem->Absx) && (x <= (pstrItem->Absx+pstrItem->length))
	&&	(y>=pstrItem->Absy) && (y <= (pstrItem->Absy+pstrItem->height))	)
	{
		*pstrClickedItem = pstrItem;
		list_for_each(pos, &pstrItem->items)
		{
			pstrtmpitem = list_entry(pos, UW_Window, node);
	        	if (pstrtmpitem->visible == 1)
	            		UW_GetItemClicked(pstrtmpitem, pstrClickedItem, x, y);
		}
	}	
}

/*!
 * \brief API Set List Box Items Height
 *
 * This should set List Box Items Height
 *
 * \param[in] pListBox: pointer to UWindow Object treated as ListBox
 * \param[in] value	: Height of Items
 * \return none 
 */
void	UW_ListBoxSetItemHeight(UW_Window *pListBox,u8 value)	
{													
	UW_ListBox	* Properties = (pListBox)->ExtraProperties;	
	Properties->ItemHeight	= value;					
	Refresh					= 1;						
}
/*!
 * \brief increment the index of available items
 *
 * This is used when scrolling down a list box
 *
 * \param[in] pListBox: pointer to UWindow Object treated as ListBox
 * \return none 
 */
static void UW_ListBoxIncStart(UW_Window * pListBox)
{
	UW_ListBox *	Properties = pListBox->ExtraProperties;
	if (Properties->StartItem->node.next != &(Properties->items))
		Properties->StartItem= list_entry(Properties->StartItem->node.next,UW_Window,node);
	return;	
}

/*!
 * \brief decrement the index of available items
 *
 * This is used when scrolling up a list box
 *
 * \param[in] pListBox: pointer to UWindow Object treated as ListBox
 * \return none 
 */
static void UW_ListBoxDecStart(UW_Window * pListBox)
{
	UW_ListBox *	Properties = pListBox->ExtraProperties;
	if (Properties->StartItem->node.prev != &(Properties->items))
		Properties->StartItem = list_entry(Properties->StartItem->node.prev,UW_Window,node);
	return;	
}

/*!
 * \brief Handle a click a list box
 *
 * This is used to handle list box click. it will either:
 *			change Active Element
 * 			Scroll UP
 *			Scroll Down
 *
 * \param[in] pListBox: pointer to UWindow Object treated as ListBox
 * \return none 
 */
static void UW_HandleListBoxClicked(UW_Window * pListBox, u8 x, u8 y)
{
	u8	index=0;
	struct list_head * 	pos;
	UW_Window * 	pstrtmpitem;
	UW_ListBox *	pstrProperties = pListBox->ExtraProperties;
	UW_Window * 	pstrItem = NULL;
	UW_GetItemClicked(&pstrProperties->BtnDwn,&pstrItem,x,y);
	if (pstrItem != NULL)
	{
		UW_ListBoxIncStart(pListBox);
		return;
	}	
	UW_GetItemClicked(&pstrProperties->BtnUp,&pstrItem,x,y);
	if (pstrItem != NULL)
	{
		UW_ListBoxDecStart(pListBox);
		return;
	}
	list_for_each(pos, &pstrProperties->items)
	{
		pstrtmpitem = list_entry(pos, UW_Window, node);
		UW_GetItemClicked(pstrtmpitem,&pstrItem,x,y);
		if (pstrItem != NULL)
		{
			pstrProperties->ActiveItem = pstrItem;
			break;
		}
		//index++;
	}
}


/*!
 * \brief general Handling of click even
 *
 * This is used handle a click event on touch screen
 *
 * \param[in] pstrItem: pointer to UWindow Object
 * \param[in] x: X position of click
 * \param[in] y: Y position of click
 * \return none 
 */
static void UW_HandleItemClicked(UW_Window * pstrItem, u8 x,u8 y)
{
	if (pstrItem->type == UW_CHECKBOX)
	{
		if (pstrItem->value == 0)
			pstrItem->value = 1;
		else
			pstrItem->value = 0;        
	}
	 if (pstrItem->type == UW_BUTTON)
	{
		u32 BGColor;
		u32 temp;
        	BGColor = DRAW_GetBGndColor();    
		LCD_FillRect(pstrItem->Absx,pstrItem->Absy,pstrItem->length,pstrItem->height,BLUE);	
		for (temp=0; temp<0x4FFF; temp++);
		LCD_FillRect(pstrItem->Absx,pstrItem->Absy,pstrItem->length,pstrItem->height,BGColor);
	}
	if (pstrItem->type == UW_EDIT)
		CharSet_Show(pstrItem);
	if (pstrItem->type == UW_LISTBOX)
		UW_HandleListBoxClicked(pstrItem,x,y);
	if (pstrItem->CallBacks.Click != NULL)
		pstrItem->CallBacks.Click(pstrItem);
	Refresh = 1;
}

/*!
 * \brief API add item to list box
 *
 * This is used add item to list box
 *
 * \param[in] pListBox: pointer to UWindow Object treated as ListBox
 * \param[in] Item: a new Item, pointer t UWindow treated as EditBox
 * \return none 
 */
void UW_ListBoxAddItem(UW_Window *ListBox, UW_Window *Item)
{
    UW_ListBox	* Properties = ListBox->ExtraProperties;
    INIT_LIST_HEAD(&Item->items);    
	Item->enable	= 1;
	list_add_tail(&(Item->node),&Properties->items);
    Properties->ItemsCount++;
	Refresh	= 1;
	if (Properties->StartItem == NULL)
		Properties->StartItem = Item;
}

/*!
 * \brief API remove item from list box
 *
 * This is used remove item from list box
 *
 * \param[in] pListBox: pointer to UWindow Object treated as ListBox
 * \param[in] Item: a new Item, pointer t UWindow treated as EditBox
 * \return none 
 */
void UW_ListBoxRemoveItem(UW_Window * ListBox, UW_Window * Item)
{
	UW_ListBox	* Properties = ListBox->ExtraProperties;	
	if (Properties->StartItem == Item)
		Properties->StartItem= list_entry(Properties->StartItem->node.next,UW_Window,node);
	if (Properties->ActiveItem == Item)
		Properties->ActiveItem= list_entry(Properties->ActiveItem->node.next,UW_Window,node);
	list_del(&(Item->node));
    Properties->ItemsCount--;
	Refresh	= 1;
}

/*!
 * \brief get active item
 *
 * This is used get current item currently pointed to in ListBox
 *
 * \param[in] pListBox: pointer to UWindow Object treated as ListBox
 * \return pointer to UWindow Object Active Item in list Box
 */
UW_Window * UW_ListBoxGetActiveItem(UW_Window * ListBox)
{
	UW_ListBox	* Properties = ListBox->ExtraProperties;
	return Properties->ActiveItem;
}

/*!
 * \brief get item with a certain index
 *
 * Items are indexed from 0 to TotalCount-1, This is used get item with certain index
 *
 * \param[in] pListBox: pointer to UWindow Object treated as ListBox
 * \param[in] index: index of the Item
 * \return pointer to UWindow Object Active Item in list Box
 */
UW_Window * UW_ListBoxGetItem(UW_Window * ListBox,u32 index)
{
	u32	CurrentIndex = 0;
	UW_Window * Item = NULL;
	UW_ListBox	* Properties = ListBox->ExtraProperties;
	struct list_head * 	pos;
	list_for_each(pos, &Properties->items)
	{
		if (CurrentIndex == index)
		{
			Item = list_entry(pos, UW_Window, node);
			break;
		}
		CurrentIndex++;
	}
	return Item;
}

s32 UW_ListBoxGetIndex(UW_Window * ListBox,UW_Window * Item)
{
	s32	CurrentIndex = 0;
	UW_Window * tmpItem = NULL;
	UW_ListBox	* Properties = ListBox->ExtraProperties;
	struct list_head * 	pos;
	list_for_each(pos, &Properties->items)
	{
		tmpItem = list_entry(pos, UW_Window, node);
		if (tmpItem == Item)
		{
			return CurrentIndex;
		}
		CurrentIndex++;
	}
	return -1;
}

/*!
 * \brief Eixt Windows
 *
 * set bExit Flag to exit Windows
 *
 * \return none
 */
void ExitUWindows(void)
{
	bExit	= 1;
}
/*!
 * \brief API to initialize UWindows
 *
 * This should be called at Application Init
 *
 * \return none
 */
void UW_Init(void)
{
#ifdef _MIOS32_CONFIG_H
  UWBitmap = MIOS32_LCD_BitmapInit((u8 *)UWImage, 
				   APP_LCD_NUM_X*APP_LCD_WIDTH,
				   APP_LCD_NUM_Y*APP_LCD_HEIGHT,
				   APP_LCD_NUM_X*APP_LCD_WIDTH,
				   APP_LCD_COLOUR_DEPTH);
#endif
	UWindows.type		= UW_FORM;	
	UWindows.Absx		= 0;
	UWindows.Absy		= 0;
    UWindows.length   	= MAX_X;
   	UWindows.height   	= MAX_Y;
    UWindows.visible  	= 1;
	UWindows.enable		= 1;
	UWindows.CallBacks.Click = NULL;
	INIT_LIST_HEAD(&UWindows.items);
  	UWindows.caption 	= NULL;
  	UWindows.captionlen = 0;
	Refresh 			= 1;  
	CursorXPos 			= 64;
	CursorYPos			= 64;
    pUW_Infocus			= &UWindows;
	bExit				= 0;
	UW_Add(&ExitBtn,UW_BUTTON,&UWindows,NULL);
	UW_SetSize(&ExitBtn,MAX_X,20);
	UW_SetCaption(&ExitBtn,ExitLabel,9);
	UW_SetOnClick(&ExitBtn,ExitUWindows);
	CharSet_Init();
	//UW_TSInit();
}
/*!
 * \brief API main running function of UWindows
 *
 * This should be called at Application Handler
 *
 * \return none
 */
void UW_Run(void)
{
	// Need to add my own handler code here 
	// As this is circle_os specific
	/*
    if (UW_TSCalibrate() == MENU_CONTINUE)
	return ;
	if (UW_TSIsClicked() == 1)//Exit of application
	{
        	UW_Window * pstrItem;
	    	u16 u16pos;
	    	u8 u8xpos,u8ypos;
		u16pos = UW_TSGetPos();
		u8xpos = (u8) ((u16pos & 0xFF) );
		u8ypos = (u8)  (((u16pos >> 8) & 0xFF));
		pstrItem = NULL;
		CursorXPos = u8xpos;
		CursorYPos = u8ypos;
		if (CharSetWindow.visible == 1)
			UW_GetItemClicked(&CharSetWindow, &pstrItem, u8xpos, u8ypos);		
		else		
		{
			UW_GetItemClicked(&UWindows,&pstrItem,u8xpos,u8ypos);
			pUW_Infocus = pstrItem;			
		}
        UW_HandleItemClicked(pstrItem,u8xpos,u8ypos);		
	}
	if (BUTTON_GetState() == BUTTON_PUSHED)
	{
		BUTTON_WaitForRelease();
		if (pUW_Infocus->CallBacks.ButtonPress != NULL)
			pUW_Infocus->CallBacks.ButtonPress(pUW_Infocus,PUSHED);
	}
	else if (JOYSTICK_GetState() >= JOYSTICK_LEFT)
	{        	
		if (pUW_Infocus->CallBacks.ButtonPress != NULL)
			pUW_Infocus->CallBacks.ButtonPress(pUW_Infocus,JOYSTICK_GetState());
	} */
	UW_HandleTimer(&UWindows);
	if (Refresh == 1) 
    {
		if (CharSetWindow.visible == 1)
			UW_DrawItem(&CharSetWindow);
		else
			UW_DrawItem(&UWindows);		
		UW_DrawImage();
		#ifdef	SHOW_CURSOR
			UW_DrawCursor(CursorXPos,CursorYPos);
		#endif	   
		Refresh = 0;	
	}
	return;

}

